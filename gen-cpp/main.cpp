// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <bits/stdc++.h>
#include "KC_Storage.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

//Kyoto Cabinet database
#include <kchashdb.h>

//KC Storage Service Interface.

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace kyotocabinet;

using namespace  ::KC_Storage;

class KC_StorageHandler : virtual public KC_StorageIf {
private:
    HashDB db;
public:
    KC_StorageHandler() {
        // Your initialization goes here
        std::cout << "Server Starting........." <<std::endl;
        std::cout << std::endl;
        
        if (db.open("db.kch", HashDB::OWRITER | HashDB::OCREATE)) {
            std::cout << "open KC database success" << std::endl; 
        } else {
            std::cerr << "open error: " << db.error().name() << std::endl; 
        }
    }

    ~KC_StorageHandler() {
        if (db.close()) {
            std::cout << "close KC database success" << std::endl;
        } else {
            std::cerr << "close error: " << db.error().name() << std::endl;
        }
    }    
    int32_t totalRecord() {
        // Your implementation goes here
        printf("totalRecord\n");
        int res = db.count();
        return res;
    }

    void get(std::string& _return, const std::string& key) {
        // Your implementation goes here
        std::string res;
        bool ok = db.get(key,&res);
        if (ok == true){
            _return = res;
        } else {
            _return = "";
        }
        printf("get\n");
    }

    bool put(const std::string& key, const std::string& value, const putOption::type opt) {
        // Your implementation goes here

        printf("put\n");
        
        switch (opt){
            case putOption::type::add:
                {
                    bool ok = db.set(key, value);
                    return ok;
                }
                break;
            case putOption::type::overide:
                {
                    bool ok = db.set(key, value);
                    return ok;
                }
                break;
            case putOption::type::update:
                {
                    int re = db.check(key);
                    if (re == -1){
                        return false;
                    } else {
                        bool ok = db.set(key, value);
                        return ok;
                    }    
                }
                break;
        }
        
    }

    bool remove(const std::string& key) {
        // Your implementation goes here
        
        printf("remove\n");
    }

};

int main(int argc, char **argv) {
    int port = 9876;
    shared_ptr<KC_StorageHandler> handler(new KC_StorageHandler());
    shared_ptr<TProcessor> processor(new KC_StorageProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
    
    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}



